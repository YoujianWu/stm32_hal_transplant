用keil仿真调试时，应该注意的：
1.使用logic analyze分析波形时，如果想要看IO口波形，选择“setup”，然后设置
  (PORTA & 0x08) >> 3，也就是选择PA3,接着数据类型选bits，否则会无法显示波形。

移植标准库/HAL库的注意事项：
1.启动文件要单独放在一个文件夹StartUp里面。（上电时第一个跑的程序）
2.内核驱动文件、外设描述文件、system启动文件要单独放在一个文件夹Start里面。（固件库）
3.标准库/HAL库单独放在Libararies里面，另外还有中断库文件（.c/.h）和库的配置文件（config）
  以及msp（如果有的话）。
4.自己的外设驱动放在Hardware里面
5.User文件夹放应用层文件，main函数，system文件（系统滴答、HAL库、时钟初始化），config
（包含常用库和system）文件等。
6.移植的所以文件可以在ST提供的固件包里找到，其他所需要的文件或者main函数还可以去里面的例程里面找，
库里面可能会有template后缀的库文件，删除即可。
7.移植过程中，先不要添加标准库/HAL库进入项目编译，先加入StartUp、Start、User编译，保证固件库编
译通过后，再添加库文件进行编译，所有的“main.h”都换成"config.h"

在源文件里面声明了全局变量struct Timer mtimer1，然后又在头文件里面extern struct Timer mtimer1，是为了
保证编译时，不会出现多次包含头文件，导致变量冲突的问题

Multi_timer使用时，记得将timer_ticks()放在SysTick_Handler()里面，给它的定时器提供时基，因为HAL_SYSTICK_IRQHandler
在中断向量表里没写，没办法调用，可能是因为STM32F1系列的问题吗？

Multi_Button 要在 5ms 定时器中断中调用button_ticks()，5ms扫描一次按键，非常方便

当外部事件或内部事件满足条件时，会触发中断，调用中断向量表指向的函数，多个中断则按照优先级触发，重写中断函数有两种：
1.重写USART1_IRQHandler（中断向量表指向的函数），可以在里面实现自己的功能（这种是标准库的写法，查标志位，执行代码，清除标志位）
2.重写HAL_UART_TxCpltCallback（中断会先触发USART1_IRQHandler，然后调用HAL_UART_IRQHandler(&huart1)，在这个
函数里面会调用HAL_UART_TxCpltCallback，所以我们只需要重写这个回调函数即可，具体可以看it.c中断库）（这是封装了一层的写法）

Gpio中断模式：
External Interrupt Mode with Falling edge trigger detection(外部中断模式):
“我检测到下降沿了，请CPU马上来处理！”
External Event Mode with Falling edge trigger detection(外部事件模式)：
“我检测到下降沿了，直接通知ADC开始采样，不用打扰CPU。”


定时器的基本知识：若已经知道定时器所在总线的时钟频率，那么分频系数就是对其分频，得到定时器基本的运行频率，再设置计数值即可实现不同类型的计数
eg: 若总线运行频率为72MHZ，72分频（HAL填的时候是72-1）（65536）（最大），计数值为1000（填的时候填1000-1）（最大65536）,则计数时间为：1/(72MHZ/72)*1000 = 0.001s = 1ms
占空比的脉宽（Pluse）值（比较值）=50%*1000=500

定时器分为基本定时器、通用定时器、高级定时器，在stm32中tim1和tim8属于高级定时器，tim2-tim5为通用定时器，tim6、tim7属于基本定时器
基本定时器：主要用于产生定时中断（就和multi_timer一样）
通用定时器：包含多个捕获/比较通道，可以实现输入捕获、输出比较、PWM生成、单脉冲模式等多种功能。是应用最广泛的定时器类型
高级定时器：除了具备通用定时器的所有功能外，还有以下功能：
互补输出 (Complementary Outputs)：每个通道都有一个互补的输出引脚，这对于驱动H桥或三相电机至关重要，可以防止上下桥臂直通
死区时间插入 (Dead-time Insertion)：在互补输出的高电平和低电平之间插入一段延迟时间，确保同一桥臂的上下两个开关管不会同时导通，提高系统安全性
刹车功能 (Break Function / Braking)：可以由外部信号或内部错误快速强制关闭PWM输出，实现紧急停机，保护功率器件
更复杂的计数模式和同步功能：支持更灵活的时钟源选择、多种时钟模式和与其他定时器的同步
重复计数器 (Repetition Counter)：允许定时器在溢出前重复计数多次，用于实现更复杂的周期控制

在STM32高级定时器中生成互补PWM时，"Slave Mode"（从模式）是指定时器作为从机，根据外部或内部触发信号来控制其计数行为（如启动、复位或同步），
实现与其他外设的精确协同；而"Trigger Sources"（触发源）则是指这些控制信号的来源，可来自其他定时器的事件输出（如更新事件）或外部引脚信号。
通过配置触发源和从模式，可以实现多个定时器或PWM与ADC等外设之间的硬件级同步，广泛应用于电机控制、电源管理等需要高精度时序配合的场景。
在实际应用中，例如使用TIM1生成三相互补PWM信号进行电机控制时，可将其更新事件（Update Event）配置为触发输出（TRGO）；同时设置TIM2为从模式，
并选择TIM1的输出作为触发源（如通过ITR0）。当TIM1每完成一个PWM周期并产生更新事件时，会自动触发TIM2启动一次ADC采样，从而实现电流采样与PWM信号的硬件同步。
这种方式避免了软件延迟，确保了控制系统的实时性与精度

高级定时器输出互补PWM波（驱动一对MOS管一定要设置死区时间，死区时间=装载*0.3（即是相移），否则会烧毁一对MOS管）：
Slave Mode，Trigger Source选择Disable，时钟源选择内部时钟，72分频，装载100，占空比脉宽（Pluse）设置为0，程序里面改，
选择PWM Mode1，那么则输出10KHZ的PWM波


HAL只负责初始化，需要自己开启的：
1.各种中断
2.PWM波